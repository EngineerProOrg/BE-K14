1. Requirement:
- Functional:
    - Register, login, logout
    - Profile: edit user data (name, age, avatar)
    - Newsfeed: post, view newsfeed
        - Post: comment, react
    - Follow/unfollow users, view user's follow list
    - Notification (Realtime):
        - Follow me
        - Comment, react post
        - Newsfeed: add latest posts

- Non-functional:
    - Performance: P99: API latency < 100ms, max 500ms (99%)
    - Security: user data: password, user info ..
    - ...

2. Estimation: ( QPS, storage: (db, images), .. )
- target: 100M users
- daily, 20% users online, 3h: 20M users/daily
- post: 3 posts => daily new posts: 3 post/day * 10M = 30M posts.
    - post: 1000 chars, 10 images, image size: 5Mb
    - => post storage: 30M * 8kb = 240 Gb / daily
      comments:
      image storage: 30M * 5Mb = 150 Tb / daily
      QPS: 60M/daily, 86k s => 1M QPS
    - comment/react: 10M users, 10% comment/react => 1M QPS
- newsfeed:
    - QPS: 10M users -> 10M QPS
- user: login, edit user profile, ...

=> QPS: 
- Read QPS: 10M QPS ( newsfeed API)
- Write QPS: 2M QPS ( post/comment/react APIs)

=> Data storage:
- DB:
  - Post: 240Gb/day => 240 * 360 * 10 => /year
  - User: 100M users => 1 user: name, email, password, .... => 1Mb => 200Tb
  - Storage:
- Images: 150 Tb / daily => *360 *10

3.  Data model:
    Biz model -> technical model
- User:
    - Fields: username, password, name, dob, email, ...
    - Actions:
        - login, logout, register, edit profile
        - create/edit/remove posts, comments, react
        - follow/unfollow users
        - view newsfeed
        - view user's post list
- Post:
    - Fields: owner, timestamp, content, image_urls
    - Actions: ...
- Comment:
  _ Fields: owner, timestamp, content, post
- React (like):
    - Fields: owner, timestamp, post

Follows: options (pros/cons)

a. user_users:
- user_id: indexed
- followed_by_user_id

pros:
- easy management, friendly -> relational db
- add/remove: easily

cons:
- get following user ids: -> O(n)
- need index

b. users:
- following_user_ids: [int] -> user_id
- following_users: [{id, user_name}]

pros:
- get following user ids: O(1) -> query ids -> data
- read

cons:
- remove: O(n)
- set nx lock_{{user_id}}
- -> instance: {{user_id}} -> lock golang, no need redis

4. API
5. High level design
- Scale:
    - Business logic: service (go, java, c++)
        - Seperate domain: workload by domain
        - Horizontal scale: increase instances, workload by physical machines
          => core mindset => make services "distributed"
            - parallel

    - Data:
        - Replica: workload by replica (same data): read QPS
        - Partition:
            - Table: workload by data partitions: read+write QPS
                - Users: 100M -> 100 tables, 1M users
            - Database:
                - Users, posts, comments ..
                - 2 dbs:
                    - Users
                    - Posts, comments, ... 

6. Detail design

Login:

API /login -> HTTP (validate data, ..) -> User service -> DB
password: raw password. db: hashed: cpu 
